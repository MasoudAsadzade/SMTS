smts.cnf = {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // DATA TYPES
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Clause: A clause that groups different literals. Here, the clause is
    // represented by its ID number.
    // Type: number

    // Variable: A variable appearing in a literal.
    // Type: string
    // E.g.: 'e0'

    // LiteralName: The structure containing the literal formula.
    // The first element of the array is the identifier of the function
    // representing the literal. All the other elements are parameters, either
    // other functions or variables.
    // Type: LiteralName[] or Variable[]
    // E.g.: ['op' [ 'op' [ 'not' 'e2' ] 'e1' ] [ 'and' 'e0' 'e1' ] ]

    // Literal: Object representing a literal.
    // Type: {
    //     id:        number,
    //     name:      literalName,
    //     variables: Variable[],
    //     clauses:   ClauseId[]
    // }


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // MEMBERS
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // {Literal[]} literals: Literals are stored at index equal to their ID.
    literals: [],

    // {vis.Network} network: Network generated by the vis.js library.
    network:  null,

    // {object} options: Options used by the vis.js network.
    options: {
        interaction: {
            dragNodes: true,
            hideEdgesOnDrag: true
        },
        nodes: {
            shape: 'circle',
            color: {
                highlight: {
                    border:     '#a30101',
                    background: '#ff4c4c'
                }
            }
        },
        edges: {
            smooth: false
        },
        layout: {
            improvedLayout: false
        },
        physics: {
            enabled: true,
            stabilization: {enabled: true, iterations: 1000}
        }
    },


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // METHODS
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Parse a literal name and extract its variables
    // @param {LiteralName} literalName: The name of the literal to be parsed.
    // @return {Variable[]}: The list of variables appearing in the literal.
    getVariables: function(literalName) {
        let variables = [];
        makeVariablesRec(literalName, variables);
        return variables;

        function makeVariablesRec(literalName, variables) {
            if (typeof literalName === 'string') {
                if (!variables.includes(literalName)) {
                    variables.push(literalName);
                }
            } else {
                for (let i = 1; i < literalName.length; ++i) {
                    makeVariablesRec(literalName[i], variables);
                }
            }
        }
    },


    // Get list of IDs of literals that have to be selected.
    // The selection is made based on the variable and clause switches, and on
    // the active clauses and variables (clauses and variables for which the
    // corresponding button is active in the literal info panel).
    // If the clause switch is on 'OR', the clause condition is satisfied if at
    // least one of the active clauses is present in the literal (N.B.: if no
    // clause is active, then the condition is not satisfied). If the clause
    // switch is on 'AND', the clause condition is true if all the active
    // clauses are present in the literal. The same holds for the variable
    // condition.
    // If both the the clause and variable conditions are satisfied for a
    // particular literal, then its corresponding node is selected.
    // @param {Variable[]} variables: List of variable to be compared with each
    // literal.
    // @param {Clause[]} clauses: List of clauses to be compared with each
    // literal.
    // @return {number[]}: List of IDs of literals to be selected.
    getSelectedLiteralIds: function(variables, clauses) {
        // An active switch represents an 'or', otherwise an 'and'
        let orVariables = $('#smts-content-cnf-literal-info-variables-switch').bootstrapSwitch('state');
        let orClauses   = $('#smts-content-cnf-literal-info-clauses-switch').bootstrapSwitch('state');

        // If the switch is on 'or', then use `some`, otherwise use `every`
        let testVariables = orVariables ? Array.prototype.some : Array.prototype.every;
        let testClauses   = orClauses   ? Array.prototype.some : Array.prototype.every;

        testVariables = testVariables.bind(variables);
        testClauses   = testClauses.bind(clauses);

        let selectedLiteralIds = [];
        for (let literal of this.literals) {
            if (testClauses(includes.bind(literal.clauses)) &&     // Some/every clause is in literal.clauses
                testVariables(includes.bind(literal.variables))) { // Some/every variable is in literal.variables
                selectedLiteralIds.push(literal.id);
            }
        }

        return selectedLiteralIds;

        // Custom `includes` function
        // The method `Array.prototype.includes` doesn't work well with
        // `Array.prototype.some` and `Array.prototype.every`.
        function includes(target) {
            for (let element of this) if (target === element) return true;
            return false;
        }
    },


    // Update and display the selected nodes
    // The selection is done based on the literal info panel selections (see
    // `getSelectedLiteralIds` for more details).
    // N.B.: Since this function is called from a click event listener, `this`
    // is bound to the DOM element, not to the `smts.cnf` object.
    updateSelectedNodes: function() {
        // Toggle clicked button active state
        this.classList.toggle('active');

        // Get list of active variable buttons
        let variables = [];
        let variableBtns = document.getElementById('smts-content-cnf-literal-info-variables');
        for (let variableBtn of variableBtns.childNodes) {
            if (variableBtn.classList.contains('active')) {
                variables.push(variableBtn.getAttribute('data-variable'));
            }
        }

        // Get list of active clause buttons
        let clauses = [];
        let clausesBtns = document.getElementById('smts-content-cnf-literal-info-clauses');
        for (let clauseBtn of clausesBtns.childNodes) {
            if (clauseBtn.classList.contains('active')) {
                clauses.push(parseInt(clauseBtn.getAttribute('data-clause')));
            }
        }

        // Get literals that match the active variables and clauses
        let selectedLiteralIds = smts.cnf.getSelectedLiteralIds(variables, clauses);

        // Add current literal to selected list (current should always be selected)
        let literalInfo = document.getElementById('smts-content-cnf-literal-info');
        let literalId = literalInfo.getAttribute('data-literal-id');
        if (!selectedLiteralIds.includes(literalId)) {
            selectedLiteralIds.push(literalId);
        }

        // Select nodes
        if (smts.cnf.network) {
            smts.cnf.network.selectNodes(selectedLiteralIds, false);
        }
    },

    // Populate the literal info panel with literal information
    // @param {number} literalId: id of the literal to load in the info panel.
    // If no id is provided, then the panel gets hidden.
    generateLiteralInfo: function(literalId) {
        let literalInfo = document.getElementById('smts-content-cnf-literal-info');

        if (!literalId) {
            literalInfo.classList.add('smts-hidden');
        } else {
            let literal = this.literals[literalId];
            literalInfo.setAttribute('data-literal-id', literalId);

            // Clear previous info
            let variableBtns = document.getElementById('smts-content-cnf-literal-info-variables');
            let clauseBtns   = document.getElementById('smts-content-cnf-literal-info-clauses');
            variableBtns.innerHTML = '';
            clauseBtns.innerHTML   = '';

            // Make variables buttons
            for (let variable of literal.variables) {
                let variableBtn = document.createElement('div');
                variableBtn.classList = 'btn btn-default btn-xs';
                variableBtn.setAttribute('data-variable', variable);
                variableBtn.innerHTML = variable;
                variableBtn.addEventListener('click', this.updateSelectedNodes);
                variableBtns.appendChild(variableBtn);
            }

            // Make clauses buttons
            for (let clause of literal.clauses) {
                let clauseBtn = document.createElement('div');
                clauseBtn.classList = 'btn btn-default btn-xs';
                clauseBtn.setAttribute('data-clause', clause);
                clauseBtn.innerHTML = clause;
                clauseBtn.addEventListener('click', this.updateSelectedNodes);
                clauseBtns.appendChild(clauseBtn);
            }

            let formula = document.getElementById('smts-content-cnf-literal-info-formula');
            formula.innerHTML = literal.name;

            // Show info
            literalInfo.classList.remove('smts-hidden');
        }
    },

    // Get vis.js compatible data to build the network
    // @param {object} cnf: CNF formula as an object.
    // @return {object}: Object containing nodes and edges for vis.js network.
    getData: function(cnf) {
        // Vis nodes and edges
        this.literals = [];
        let nodes = [];
        let edges = [];

        // Use numeric ids instead of strings to speed up vis.js
        let literalIds = {};   // Dictionary {string: number} to map literal names to ids
        let nextLiteralId = 0; // Counter to retrieve next available id

        for (let i = 1; i < cnf.length; ++i) {         // cnf[0] == 'and'
            let clause = cnf[i];

            for (let j = 1; j < clause.length; ++j) {  // cnf[i][0] == 'or'
                let literalName = clause[j];

                if (!literalIds[literalName]) {
                    // Map literal to a new id
                    let literalId = nextLiteralId++;
                    literalIds[literalName] = literalId;
                    this.literals[literalId] = {
                        id:        literalId,
                        name:      JSON.stringify(literalName),
                        variables: this.getVariables(literalName).sort(),
                        clauses:   []
                    };

                    // Add literal to nodes
                    nodes.push({
                        id: literalId
                    });
                }

                // Build edges from all previous to current node in same clause
                let literalId = literalIds[literalName];
                for (let k = 1; k < j; ++k) {
                    edges.push({
                        from: literalId,
                        to:   literalIds[clause[k]]
                    });
                }

                // Add clause to literal (`i` is the clause id)
                let literal = this.literals[literalId];
                if (!literal.clauses.includes(i)) {
                    literal.clauses.push(i);
                }
            }
        }

        return { nodes: nodes, edges: edges};
    },


    // Initialize and render CNF network
    // @params {string} cnfData: CNF data obtained from solver as a string.
    init: function(cnfData) {
        // Make data json compatible
        let cnfDataJson = cnfData
            .replace(/ \.\w+/g, '')     // Remove words starting with '.' (and remove space too)
            .replace(/\(/g, '[')        // Replace '(' with '['
            .replace(/\)/g, ']')        // Replace ')' with ']'
            .replace(/ /g, ',')         // Replace ' ' with ','
            .replace(/=/g, '"="')       // Wrap '=' with quotes
            .replace(/(\w+)/g, '"$1"'); // Wrap words with quotes

        // Parse data
        let cnf = JSON.parse(cnfDataJson);

        // HTML element into which the network is injected
        let visContainer = document.getElementById('smts-content-cnf-container');

        // Build nodes and edges
        let data = this.getData(cnf);
        let visNodes = new vis.DataSet(data.nodes);
        let visEdges = new vis.DataSet(data.edges);
        let visData  = {nodes: visNodes, edges: visEdges};

        // Options
        let visOptions = this.options;

        // Network
        this.network = new vis.Network(visContainer, visData, visOptions);

        // Stop physics once the network is rendered
        this.network.on('stabilizationIterationsDone', () => {
            this.network.setOptions({physics: false});
        });

        // Show literal info
        this.network.on('click', (data) => {
            if (data.nodes.length > 0) {
                // Generate information about first selected node
                this.generateLiteralInfo(data.nodes[0]);
            } else {
                // Remove literal information box
                this.generateLiteralInfo(null);
            }
        });
    },

    // Make GET request to retrieve CNF data and create it
    // @param {string} type: Either 'clauses' or 'learnts'.
    // @param {string} instanceName: Selected instance.
    // @param {string} value: If type is 'clauses', then value is the node
    // path, else if type is 'learnts', value is the solver address.
    create: function(type, instanceName, value) {
        $.ajax({
            url: `/cnf/${type}?instanceName=${instanceName}&value=${value}`,
            type: 'GET',
            success: function(cnfData)  {
                if (cnfData) {
                    smts.cnf.init(cnfData);
                } else {
                    console.log('NO CNF DATA');
                }
            }
        })
    }
};